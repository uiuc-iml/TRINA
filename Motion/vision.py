import pcl
import cv2
import open3d
import numpy as np

class Ply:

    """
    The Ply class provides the ability to write a point cloud represented
    by two arrays: an array of points (num points, 3), and an array of colors
    (num points, 3) to an ASCII PLY file.
    """

    def __init__(self, points, colors):
        """
        points -- 2D array of points (num points, 3)
        colors -- 2D array of colors (num points, 3)
        """
        self.__points = points
        self.__colors = colors

    def write(self, filename):
        """
        Write the point cloud data to a PLY file of the given name.
        filename -- The PLY file
        """
        # Write the headers
        lines = self.__getLinesForHeader()

        fd = open(filename, "w")
        for line in lines:
            fd.write("%s\n" % line)

        # Write the points
        self.__writePoints(fd, self.__points, self.__colors)

        fd.close()

    def __getLinesForHeader(self):
        """
        Get the list of lines for the PLY header.
        """
        lines = [
            "ply",
            "format ascii 1.0",
            "comment generated by: kinectToPly",
            "element vertex %s" % len(self.__points),
            "property float x",
            "property float y",
            "property float z",
            "property uchar red",
            "property uchar green",
            "property uchar blue",
            "end_header",
            ]

        return lines

    def __writePoints(self, fd, points, colors):
        """
        Write the point cloud points to a file.
        fd -- The file descriptor
        points -- The matrix of points (num points, 3)
        colors -- The matrix of colors (num points, 3)
        """
        # Stack the two arrays together
        stacked = np.column_stack((points, colors))

        # Write the array to the file
        np.savetxt(
            fd,
            stacked,
            delimiter='\n',
            fmt="%f %f %f %d %d %d")



class PointCloud:

    """
    The PointCloud class provides functionalities to perform basic operations with pointcloud
    """

    def __init__(self, points):
        """
        points -- 2D array of points (num points, 3)
        """
        self.__points = points

    def removeNoise(self, k = 50, std_mul = 1):

        """
        Remove noises in the pointcloud using pcl's statistical outlier removal

        k -- Number of points (k) to use for mean distance estimation int
        std_mul -- Standard deviation multiplier threshold float
        """

        cloud  = pcl.PointCloud()
        cloud.from_array(self.__points.astype(np.float32))

        fil = cloud.make_statistical_outlier_filter()
        fil.set_mean_k (k)
        fil.set_std_dev_mul_thresh (std_mul)
        filtered = fil.filter()
        self.__points = np.array(filtered.to_array())

    def down_sample(self,radius = 0.01):

        """
        Down sample pointcloud with a given voxel grid size
        radius -- size of the voxel grid in meter float
        """
        cloud  = pcl.PointCloud()
        cloud.from_array(self.__points.astype(np.float32))

        vg = cloud.make_voxel_grid_filter()
        vg.set_leaf_size(0.01, 0.01, 0.01)
        filtered = vg.filter()
        self.__points = np.array(filtered.to_array())

    def segment_regionGrowing(self, Ksearch = 50, MinClusterSize = 800, MaxClusterSize = 25000,
                              KNeighbours = 5, Smoothness = 0.8, Curvature = 0.8):
        """
        Perform segmentation with region growing segmentation
        Return a list of PointCloud objects
        """

        cloud  = pcl.PointCloud()
        cloud.from_array(self.__points.astype(np.float32))

        segments = []
        tree = cloud.make_kdtree()
        ec = cloud.make_RegionGrowing(Ksearch)
        ec.set_MinClusterSize(MinClusterSize)
        ec.set_MaxClusterSize(MaxClusterSize)
        ec.set_NumberOfNeighbours(KNeighbours)
        ec.set_SmoothnessThreshold(Smoothness)
        ec.set_CurvatureThreshold(Curvature)
        ec.set_SearchMethod(tree)
        cluster_indices = ec.Extract()

        print('cluster_indices : ' + str(cluster_indices.count) + " count.")

        for j, indices in enumerate(cluster_indices):
            # print('indices = ' + str(len(indices)))
            # points = np.zeros((len(indices), 3), dtype=np.float32)

            # for i, indice in enumerate(indices):
            #     points[i][0] = cloud_filtered[indice][0]
            #     points[i][1] = cloud_filtered[indice][1]
            #     points[i][2] = cloud_filtered[indice][2]

            points = self.__points[indices]
            segment = PointCloud(points)
            segments.append(segment)
        return segments


    def segment_clustering(self, dis_thres, MinClusterSize = 100, MaxClusterSize = 25000):

        """
        Perform segmentation with clustering
        Return a list of PointCloud objects
        """


        cloud  = pcl.PointCloud()
        cloud.from_array(self.__points.astype(np.float32))

        segments = []
        tree = cloud.make_kdtree()
        ec = cloud.make_EuclideanClusterExtraction()
        ec.set_ClusterTolerance(dis_thres)
        ec.set_MinClusterSize(MinClusterSize)
        ec.set_MaxClusterSize(MaxClusterSize)
        ec.set_SearchMethod(tree)
        cluster_indices = ec.Extract()

        print('cluster_indices : ' + str(cluster_indices.count) + " count.")

        for j, indices in enumerate(cluster_indices):

            points = self.__points[indices]
            segment = PointCloud(points)
            segments.append(segment)

        return segments

    def extract_plane(self, Ksearch = 50, dis_threshold = 0.01, distance_Weight = 0.01, max_iter = 100):


        """
        Perform plane extraction with ransac
        Return
        planes -- a list of PointCloud objects
        coefficients -- a list of plane parameters
        """


        cloud  = pcl.PointCloud()
        cloud.from_array(self.__points.astype(np.float32))
        planes = []
        seg = cloud.make_segmenter_normals(ksearch=Ksearch)
        seg.set_optimize_coefficients(True)
        seg.set_model_type(pcl.SACMODEL_NORMAL_PLANE)
        seg.set_method_type(pcl.SAC_RANSAC)
        seg.set_distance_threshold(dis_threshold)
        seg.set_normal_distance_weight(distance_Weight)
        seg.set_max_iterations(max_iter)
        plane_indices, coefficients = seg.segment()

        if len(plane_indices) == 0:
            print('Could not estimate a planar model for the given pointcloud')
            return None


        for j, indices in enumerate(plane_indices):

            points = self.__points[indices]
            plane= PointCloud(points)
            planes.append(plane)

        return (planes, coefficients)

    def filter_by_radius(self, center, Radius):

        """
        remove points further than a Radius from the center

        """

        mask = np.ones(len(self.__points))
        distance2center = np.linalg.norm(points - center, axis=2)
        mask[distance2center > Radius] = 0

        self.__points = self.__points[mask > 0]


    def remove_points_below_surface(self, coeficient):

        """
        Remove all points underneath a plane
        """

        distance = point_to_plane(self.__points, coeficient)

        self.__points = self.__points[distance > 0.005]



    def save_to_ply(self, filename):
        """
        save the current pointcloud to an ASCII PLY file.

        filename -- saving path of the meshfile str
        e.g. "data/pointcloud.ply"
        """
        colors = np.array([[150,150,150] for i in range(len(self.__points))])
        mesh = Ply(self.__points, colors)
        mesh.write(filename)


    def save_to_pcd(self, filename):

        """
        save the current pointcloud to a .pcd file

        filename -- saving path of the pointcloud str
        e.g. "data/pointcloud.ply"
        """

        cloud  = pcl.PointCloud()
        cloud.points = self.__points

        cloud.to_file(filename)


    def get_points(self):
        return self.__points


def f_min(X,p):
    plane_xyz = p[0:3]
    distance = (plane_xyz*X.T).sum(axis=1) + p[3]
    return distance / np.linalg.norm(plane_xyz)

def residuals(params, signal, X):
    return f_min(X, params)


def distance(X,p):
    plane_xyz = p[0:3]
    distance = (plane_xyz*X.T).sum(axis=1) + p[3]
    return distance / np.linalg.norm(plane_xyz)

def find_nearest(array, value):
    tree = KDTree(array)
    value = np.tile(value, (len(array),1))
    dist, index = tree.query(value)
    return (dist,index)

def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
       return v
    return v/norm

def point_to_plane(X,p):

    plane_xyz = p[0:3]
    distance = (plane_xyz*X).sum(axis=1) + p[3]
    distance = distance / np.linalg.norm(plane_xyz)
    return distance

def fitplane(points):

    XYZ = np.asarray(points.T)
    sol = leastsq(residuals, [-680.449684,-381.93864135,-1924.54861452,1490.8745174], args=(None, XYZ))[0]

    return sol
